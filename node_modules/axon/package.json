{
  "name": "axon",
  "description": "High-level messaging & socket patterns implemented in pure js",
  "version": "1.0.0",
  "author": {
    "name": "TJ Holowaychuk",
    "email": "tj@vision-media.ca"
  },
  "dependencies": {
    "debug": "*",
    "configurable": "0.0.1",
    "escape-regexp": "0.0.1"
  },
  "devDependencies": {
    "better-assert": "*",
    "should": "*",
    "mocha": "*",
    "commander": "*",
    "humanize-number": "0.0.1"
  },
  "keywords": [
    "zmq",
    "zeromq",
    "pubsub",
    "socket",
    "emitter",
    "ipc",
    "rpc"
  ],
  "repository": {
    "type": "git",
    "url": "https://github.com/visionmedia/axon.git"
  },
  "readme": "# Axon\n\n  Axon is a message-oriented socket library for node.js heavily inspired by zeromq. For a light-weight\n  UDP alternative you may be interested in [punt](https://github.com/visionmedia/punt).\n\n[![Build Status](https://travis-ci.org/visionmedia/axon.png)](https://travis-ci.org/visionmedia/axon)\n\n## Installation\n\n    $ npm install axon\n\n## Features\n\n  - message oriented\n  - automated reconnection\n  - light-weight wire protocol\n  - supports arbitrary binary message (msgpack, json, BLOBS, etc)\n  - supports JSON messages out of the box\n  - fast (~800 mb/s ~500,000 messages/s)\n\n## Events\n\n  - `close` when server or connection is closed\n  - `error` (err) when an-handled socket error occurs\n  - `ignored error` (err) when an axon-handled socket error occurs, but is ignored\n  - `socket error` (err) emitted regardless of handling, for logging purposes\n  - `reconnect attempt` when a reconnection attempt is made\n  - `connect` when connected to the peer, or a peer connection is accepted\n  - `disconnect` when an accepted peer disconnects\n  - `bind` when the server is bound\n  - `drop` (msg) when a message is dropped due to the HWM\n  - `flush` (msgs) queued when messages are flushed on connection\n\n## Patterns\n\n  - push / pull\n  - pub / sub\n  - req / rep\n  - pub-emitter / sub-emitter\n\n## Push / Pull\n\n`PushSocket`s distribute messages round-robin:\n\n```js\nvar axon = require('axon')\n  , sock = axon.socket('push');\n\nsock.bind(3000);\nconsole.log('push server started');\n\nsetInterval(function(){\n  sock.send('hello');\n}, 150);\n```\n\nReceiver of `PushSocket` messages:\n\n```js\nvar axon = require('axon')\n  , sock = axon.socket('pull');\n\nsock.connect(3000);\n\nsock.on('message', function(msg){\n  console.log(msg.toString());\n});\n```\n\nBoth `PushSocket`s and `PullSocket`s may `.bind()` or `.connect()`. In the\nfollowing configuration the push socket is bound and pull \"workers\" connect\nto it to receive work:\n\n![push bind](http://f.cl.ly/items/473u3m1a0k1i0J0I3s04/ss-push.png)\n\nThis configuration shows the inverse, where workers connect to a \"sink\"\nto push results:\n\n![pull bind](http://f.cl.ly/items/3Y0j2v153Q0l1r373i0H/ss-pull.png)\n\n## Pub / Sub\n\n`PubSocket`s send messages to all subscribers without queueing. This is an\nimportant difference when compared to a `PushSocket`, where the delivery of\nmessages will be queued during disconnects and sent again upon the next connection.\n\n```js\nvar axon = require('axon')\n  , sock = axon.socket('pub');\n\nsock.bind(3000);\nconsole.log('pub server started');\n\nsetInterval(function(){\n  sock.send('hello');\n}, 500);\n```\n\n`SubSocket` simply receives any messages from a `PubSocket`:\n\n```js\nvar axon = require('axon')\n  , sock = axon.socket('sub');\n\nsock.connect(3000);\n\nsock.on('message', function(msg){\n  console.log(msg.toString());\n});\n```\n\n `SubSocket`s may optionally `.subscribe()` to one or more \"topics\" (the first multipart value),\n using string patterns or regular expressions:\n\n```js\nvar axon = require('axon')\n  , sock = axon.socket('sub');\n\nsock.connect(3000);\nsock.subscribe('user:login');\nsock.subscribe('upload:*:progress');\n\nsock.on('message', function(topic, msg){\n\n});\n```\n\n## Req / Rep\n\n`ReqSocket` is similar to a `PushSocket` in that it round-robins messages\nto connected `RepSocket`s, however it differs in that this communication is\nbi-directional, every `req.send()` _must_ provide a callback which is invoked\nwhen the `RepSocket` replies.\n\n```js\nvar axon = require('axon')\n  , sock = axon.socket('req');\n\nsock.bind(3000);\n\nsock.send(img, function(res){\n\n});\n```\n\n`RepSocket`s receive a `reply` callback that is used to respond to the request,\nyou may have several of these nodes.\n\n```js\nvar axon = require('axon')\n  , sock = axon.socket('rep');\n\nsock.connect(3000);\n\nsock.on('message', function(img, reply){\n  // resize the image\n  reply(img);\n});\n```\n\n Like other sockets you may provide multiple arguments or an array of arguments,\n followed by the callbacks. For example here we provide a task name of \"resize\"\n to facilitate multiple tasks over a single socket:\n\n```js\nvar axon = require('axon')\n  , sock = axon.socket('req');\n\nsock.bind(3000);\n\nsock.send('resize', img, function(res){\n\n});\n```\n\n Respond to the \"resize\" task:\n\n```js\nvar axon = require('axon')\n  , sock = axon.socket('rep');\n\nsock.connect(3000);\n\nsock.on('message', function(task, img, reply){\n  switch (task.toString()) {\n    case 'resize':\n      // resize the image\n      reply(img);\n      break;\n  }\n});\n```\n\n## PubEmitter / SubEmitter\n\n  `PubEmitter` and `SubEmitter` are higher-level `Pub` / `Sub` sockets, using the \"json\" codec to behave much like node's `EventEmitter`. When a `SubEmitter`'s `.on()` method is invoked, the event name is `.subscribe()`d for you. Each wildcard (`*`) or regexp capture group is passed to the callback along with regular message arguments.\n\napp.js:\n\n```js\nvar axon = require('axon')\n  , sock = axon.socket('pub-emitter');\n\nsock.connect(3000);\n\nsetInterval(function(){\n  sock.emit('login', { name: 'tobi' });\n}, 500);\n```\n\nlogger.js:\n\n```js\nvar axon = require('axon')\n  , sock = axon.socket('sub-emitter');\n\nsock.bind(3000);\n\nsock.on('user:login', function(user){\n  console.log('%s signed in', user.name);\n});\n\nsock.on('user:*', function(action, user){\n  console.log('%s %s', user.name, action);\n});\n\nsock.on('*', function(event){\n  console.log(arguments);\n});\n```\n\n## Socket Options\n\nEvery socket has associated options that can be configured via `get/set`.\n\n  - `identity` - the \"name\" of the socket that uniqued identifies it.\n  - `retry timeout` - connection retry timeout in milliseconds [100]\n  - `retry max timeout` - the cap for retry timeout length in milliseconds [5000]\n  - `hwm` - the high water mark threshold for queues [Infinity]\n\n## Binding / Connecting\n\nIn addition to passing a portno, binding to INADDR_ANY by default, you\nmay also specify the hostname via `.bind(port, host)`, another alternative\nis to specify the url much like zmq via `tcp://<hostname>:<portno>`, thus\nthe following are equivalent:\n\n```\nsock.bind(3000)\nsock.bind(3000, '0.0.0.0')\nsock.bind('tcp://0.0.0.0:3000')\n\nsock.connect(3000)\nsock.connect(3000, '0.0.0.0')\nsock.connect('tcp://0.0.0.0:3000')\n```\n\n## Protocol\n\nThe wire protocol is simple and very much zeromq-like, where `<length>` is\na BE 24 bit unsigned integer representing a maximum length of roughly ~16mb. The `<meta>`\ndata byte is currently only used to store the codec, for example \"json\" is simply `1`,\nin turn JSON messages received on the client end will then be automatically decoded for\nyou by selecting this same codec.\n\n```\n octet:     0      1      2      3      <length>\n        +------+------+------+------+------------------...\n        | meta | <length>           | data ...\n        +------+------+------+------+------------------...\n```\n\nThus 5 bytes is the smallest message axon supports at the moment. Later if\nnecessary we can use the meta to indicate a small message and ditch octet 2 and 3\nallowing for 3 byte messages.\n\n## Codecs\n\nTo define a codec simply invoke the `axon.codec.define()` method, for example\nhere is the JSON codec:\n\n```js\nvar axon = require('axon');\n\naxon.codec.define('json', {\n  encode: JSON.stringify,\n  decode: JSON.parse\n});\n```\n\n__Note:__ codecs must be defined on both the sending and receiving ends, otherwise\naxon cannot properly decode the messages. You may of course ignore this\nfeature all together and simply pass encoded data to `.send()`.\n\nTo use a codec in a socket pair, use the `format(<codec name>)` command. For example, to send json over a req/rep socket pair:\n\n```\nvar axon = require('axon')\n  , req = axon.socket('req')\n  , rep = axon.socket('rep')\n\nreq.format('json');\nreq.bind(3000);\n\nrep.format('json');\nrep.connect(3000);\n\nrep.on('message', function(obj, reply){\n  reply(obj);\n});\n\nreq.send({ hello: 'World' }, function(res){\n  console.log(res);\n});\n```\n\n## Performance\n\nPreliminary benchmarks on my Macbook Pro based on 10 messages\nper tick as a realistic production application would likely have\neven less than this. \"better\" numbers may be acheived with batching\nand a larger messages/tick count however this is not realistic.\n\n  64 byte messages:\n\n```\n\n      min: 47,169 ops/s\n     mean: 465,127 ops/s\n   median: 500,000 ops/s\n    total: 2,325,636 ops in 5s\n  through: 28.39 mb/s\n\n```\n\n  1k messages:\n\n```\n\n      min: 48,076 ops/s\n     mean: 120,253 ops/s\n   median: 121,951 ops/s\n    total: 601,386 ops in 5.001s\n  through: 117.43 mb/s\n\n```\n\n  8k messages:\n\n```\n\n      min: 36,496 ops/s\n     mean: 53,194 ops/s\n   median: 50,505 ops/s\n    total: 266,506 ops in 5.01s\n  through: 405.84 mb/s\n\n````\n\n  32k messages:\n\n```\n\n      min: 12,077 ops/s\n     mean: 14,792 ops/s\n   median: 16,233 ops/s\n    total: 74,186 ops in 5.015s\n  through: 462.28 mb/s\n\n```\n\n## What's it good for?\n\n  Axon are not meant to combat zeromq nor provide feature parity,\n  but provide a nice solution when you don't need the insane\n  nanosecond latency or language interoperability that zeromq provides\n  as axon do not rely on any third-party compiled libraries.\n\n## Running tests\n\n```\n$ npm install\n$ make test\n```\n\n## Authors\n\n  - [visionmedia](http://github.com/visionmedia)\n  - [gjohnson](https://github.com/gjohnson)\n\n## Links\n\n  - [Screencast](https://vimeo.com/45818408)\n  - [Axon RPC](https://github.com/visionmedia/axon-rpc)\n  - [msgpack codec](https://github.com/visionmedia/axon-msgpack)\n\n## License\n\n  MIT\n",
  "readmeFilename": "Readme.md",
  "bugs": {
    "url": "https://github.com/visionmedia/axon/issues"
  },
  "_id": "axon@1.0.0",
  "dist": {
    "shasum": "a8761befd4803fa82cce97a54351c04497ffdf04"
  },
  "_from": "axon@",
  "_resolved": "https://registry.npmjs.org/axon/-/axon-1.0.0.tgz"
}
